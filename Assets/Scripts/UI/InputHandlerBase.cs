using Scripts.Gameplay;
using Scripts.Gameplay.PlayerInput;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;

namespace Scripts.UI
{
    public abstract class InputHandlerBase : MonoBehaviour
    {
        protected bool IsPointerOverUI { get; private set; }= false;
        public bool canActWhenDead = false;
        
        protected MyPlayerInput customPlayerInput;
        protected PlayerInput cachedPlayerInputComponent;
        protected HitPoints cachedHitPoints;

        protected InputAction Move => FindAction("Move");
        protected InputAction Fire => FindAction("Fire");
        protected InputAction Kick => FindAction("Kick");

        protected InputAction Restart => FindAction("Restart");
        protected InputAction TogglePause => FindAction("TogglePause");
        
        public virtual bool IsAlive => !this.cachedHitPoints || this.cachedHitPoints.IsAlive;
        public bool ShouldProcessInput => this.canActWhenDead || this.IsAlive;

        protected virtual void Start() 
        {
            this.cachedHitPoints = this.GetComponent<HitPoints>();
        }


        protected InputAction FindAction(string actionName)
        {
            // We're supporting either the Unity PlayerInput component (MonoBehaviour)
            //  or our Autogenerated class built from the PlayerInputActions asset.
            if (!this.cachedPlayerInputComponent)
            {
                this.customPlayerInput ??= new MyPlayerInput();
                return this.customPlayerInput.FindAction(actionName);
            }

            return this.cachedPlayerInputComponent.currentActionMap?.FindAction(actionName);
        }
        
        /// <summary>
        /// Enable this.myPlayerInput sections here.
        /// </summary>
        protected virtual void OnEnable()
        {
            // Rebind the cache in case something has changed.
            this.cachedPlayerInputComponent = GetComponent<PlayerInput>();
        }

        /// <summary>
        /// Disable this.myPlayerInput sections here.
        /// </summary>
        protected virtual void OnDisable()
        {
        }
        
        protected virtual void Update()
        {
            // this variable is set in Update() to avoid a warning when IsPointerOverGameObject is called from an event handler.
            this.IsPointerOverUI = EventSystem.current && EventSystem.current.IsPointerOverGameObject();
        }

        protected bool IsGuiAction(InputAction.CallbackContext callbackContext)
        {
            return IsPointerOverUI && IsMouseClick(callbackContext);
        }
        
        protected static bool IsMouseClick(InputAction.CallbackContext callbackContext)
        {
            // Is this a mouse click?
            //  This is a hack, but they only way to filter out UGUI clicks that I've found so far.
            if (null == callbackContext.control?.device?.description) return false;
            
            return callbackContext.control.device.description.deviceClass == "Mouse";
        }
    }
}